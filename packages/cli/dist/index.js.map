{"version":3,"sources":["../src/index.ts","../src/commands/add.ts","../src/utils/logger.ts","../src/utils/get-package-info.ts"],"sourcesContent":["import \"dotenv/config\"\nimport { Command } from \"commander\";\n\nimport { add } from \"./commands/add\";\nimport { getPackageInfo } from \"./utils/get-package-info\";\n\nprocess.on(\"SIGINT\", () => process.exit(0));\nprocess.on(\"SIGTERM\", () => process.exit(0));\n\nasync function main() {\n  const packageInfo = await getPackageInfo();\n\n  const program = new Command()\n    .name(\"farmui\")\n    .description(\"Add natively farmed farmUI blocks \")\n    .version(\n      packageInfo.version || \"1.0.0\",\n      \"-v, --version\",\n      \"display the version number\",\n    );\n\n  program.addCommand(add)\n\n  program.parse();\n}\n\nmain();\n","\nimport \"dotenv/config\"\nimport { existsSync, promises as fs } from \"fs\"\nimport path from \"path\"\nimport chalk from \"chalk\"\nimport gradient from \"gradient-string\"\nimport {toBlock , toBlockString} from \"terminal-block-fonts\"\nimport { Command } from \"commander\"\nimport ora from \"ora\"\nimport { execa } from \"execa\";\nimport prompts from \"prompts\"\nimport { logger } from \"../utils/logger\"\nconst COMPONENT_REGISTERY_URL =  process.env.COMPONENTS_REGISTRY_URL ?? \"http://localhost:3000/api/components\"\nconsole.log({COMPONENT_REGISTERY_URL})\ntype CompToAddProps = {\n   comp_path: string,\n   comp_content: string,\n}\n\nconsole.log(gradient('cyan', 'pink')('FARMUI'));\n\nexport const add = new Command()\n\n\n  .name(\"farmui-add\")\n  .description(\"Adding a new component for farmui from terminal\")\n  .argument(\"<string>\", \"Id of the componnt from farmui.com\")\n  .option(\"--id\", \"id of the component\")\n  .option(\n    \"-c, --cwd <cwd>\",\n    \"the working directory. defaults to the current directory.\",\n    process.cwd()\n  )\n  .action(async (id, opts) => {\n    // already found the id and next will be finding the component id\n    \n    console.log({opts})\n    try {\n      let defaultDir = \"components\"\n      const { dir } = await prompts({\n        type: \"text\",\n        name: \"dir\",\n        message: \"A directory where it should be living\",\n        hint: \"./components \",\n      })\n      console.log({ dir })\n      if (dir) {\n        defaultDir = dir\n      }\n      // should be prompting it for the component place to be stored\n      const path_ = path.join(process.cwd(), defaultDir)\n      const root_dir = path.join(path_, \"/ui\")\n\n      const exist = existsSync(path_)\n\n      if (exist) {\n        // logic for existed\n        logger.info(\"The component already existed\")\n        const { proceed } = await prompts({\n          type: \"confirm\",\n          name: \"proceed\",\n          message: `Ready to install components and dependencies. Proceed?`,\n          initial: true,\n        })\n      }\n      console.log(path_)\n      console.log({root_dir})\n      await fs.mkdir(root_dir, { recursive: true })\n      const path_to_add: CompToAddProps[] = []\n      // const comp_db = path.join(process.cwd() + \"/ui\", \"comp.json\")\n      const comp_fetch = await fetch(COMPONENT_REGISTERY_URL!)\n      console.log(comp_fetch)\n      let comp_db: any[] = await comp_fetch.json()\n      \n      console.log(\"The file is : \", comp_db)\n    \n\n      // const comp_file = await fs.readFile(comp_db, \"utf8\")\n      // const parsed_json = await JSON.parse(comp_file)\n      // const select_files_by_id = parsed_json.find((x) => x.id === id)\n      const select_files_by_id = comp_db.find((x) => x.id === id)\n      console.log({select_files_by_id})\n      // for now , the content we will support will be react based , toll we have updated the ednpoint\n      const root_comp_name = select_files_by_id.files[0].root.name\n      const root_comp_content = select_files_by_id.files[0].root.contents[0].content\n      const root_comp_path = path.join(root_dir , root_comp_name)\n      const child_comp = select_files_by_id.files[1].child\n      \n      path_to_add.push({\n        comp_content: root_comp_content,\n        comp_path: root_comp_path\n      })\n\n      const child_path: string[] = []\n      const depends_on: any[] = child_comp\n      depends_on.map((dep)=> {\n        const child_comp_name = dep.name \n        const child_comp_content = dep.contents[0].content\n        const child_comp_path = path.join(root_dir  , child_comp_name)\n        path_to_add.push({\n          comp_content: child_comp_content,\n          comp_path: child_comp_path\n        })\n      })\n      const dependencies: string[] = select_files_by_id.dependencies\n      const spinner = ora(`Installing components...`).start()\n      if(!path_to_add) {\n        logger.warn(\"No component to add\")\n      }else {\n        path_to_add.map(async({comp_content , comp_path}) => {\n          await fs.writeFile(`${comp_path}.tsx` , comp_content)\n        })\n      }\n\n      // const path_it_self = select_files_by_id.comp_path\n      // // const dependent_path = select_files_by_id.depends_on\n      // const write_together = [path_it_self, ...dependent_path]\n       \n      // console.log({ write_together })\n      // write_together.map(async (comp) => {\n      //   const file_path = path.join(root_dir, \"commands\")\n      //   const file_path_read = path.join(file_path, comp)\n      //   console.log({ file_path_read })\n      //   const file_read = await fs.readFile(file_path_read, \"utf8\")\n      //   const write_path = path.join(path_, comp)\n      //   await fs.writeFile(write_path, file_read)\n      // })\n      // const dependencies = select_files_by_id.dependencies\n      if (dependencies?.length) {\n        await execa(\"pnpm\", ['install', ...dependencies], { cwd: process.cwd() })\n      }\n      spinner.succeed(\"Successfully installed\")\n    } catch (err) {\n      console.log(\"Error: \", err)\n    }\n  })\n","import chalk from \"chalk\"\n\nexport const logger = {\n  error(...args: unknown[]) {\n    console.log(chalk.red(...args))\n  },\n  warn(...args: unknown[]) {\n    console.log(chalk.yellow(...args))\n  },\n  info(...args: unknown[]) {\n    console.log(chalk.cyan(...args))\n  },\n  success(...args: unknown[]) {\n    console.log(chalk.green(...args))\n  },\n  break() {\n    console.log(\"\")\n  },\n}\n","import path from \"path\"\nimport fs from \"fs-extra\"\nimport { type PackageJson } from \"type-fest\"\n\nexport function getPackageInfo() {\n  const packageJsonPath = path.join(\"package.json\")\n\n  return fs.readJSONSync(packageJsonPath) as PackageJson\n}\n"],"mappings":"AAAA,MAAO,gBACP,OAAS,WAAAA,MAAe,YCAxB,MAAO,gBACP,OAAS,cAAAC,EAAY,YAAYC,MAAU,KAC3C,OAAOC,MAAU,OAEjB,OAAOC,MAAc,kBAErB,OAAS,WAAAC,MAAe,YACxB,OAAOC,MAAS,MAChB,OAAS,SAAAC,MAAa,QACtB,OAAOC,MAAa,UCVpB,OAAOC,MAAW,QAEX,IAAMC,EAAS,CACpB,SAASC,EAAiB,CACxB,QAAQ,IAAIF,EAAM,IAAI,GAAGE,CAAI,CAAC,CAChC,EACA,QAAQA,EAAiB,CACvB,QAAQ,IAAIF,EAAM,OAAO,GAAGE,CAAI,CAAC,CACnC,EACA,QAAQA,EAAiB,CACvB,QAAQ,IAAIF,EAAM,KAAK,GAAGE,CAAI,CAAC,CACjC,EACA,WAAWA,EAAiB,CAC1B,QAAQ,IAAIF,EAAM,MAAM,GAAGE,CAAI,CAAC,CAClC,EACA,OAAQ,CACN,QAAQ,IAAI,EAAE,CAChB,CACF,EDNA,IAAMC,EAA2B,QAAQ,IAAI,yBAA2B,uCACxE,QAAQ,IAAI,CAAC,wBAAAA,CAAuB,CAAC,EAMrC,QAAQ,IAAIC,EAAS,OAAQ,MAAM,EAAE,QAAQ,CAAC,EAEvC,IAAMC,EAAM,IAAIC,EAAQ,EAG5B,KAAK,YAAY,EACjB,YAAY,iDAAiD,EAC7D,SAAS,WAAY,oCAAoC,EACzD,OAAO,OAAQ,qBAAqB,EACpC,OACC,kBACA,4DACA,QAAQ,IAAI,CACd,EACC,OAAO,MAAOC,EAAIC,IAAS,CAG1B,QAAQ,IAAI,CAAC,KAAAA,CAAI,CAAC,EAClB,GAAI,CACF,IAAIC,EAAa,aACX,CAAE,IAAAC,CAAI,EAAI,MAAMC,EAAQ,CAC5B,KAAM,OACN,KAAM,MACN,QAAS,wCACT,KAAM,eACR,CAAC,EACD,QAAQ,IAAI,CAAE,IAAAD,CAAI,CAAC,EACfA,IACFD,EAAaC,GAGf,IAAME,EAAQC,EAAK,KAAK,QAAQ,IAAI,EAAGJ,CAAU,EAC3CK,EAAWD,EAAK,KAAKD,EAAO,KAAK,EAIvC,GAFcG,EAAWH,CAAK,EAEnB,CAETI,EAAO,KAAK,+BAA+B,EAC3C,GAAM,CAAE,QAAAC,CAAQ,EAAI,MAAMN,EAAQ,CAChC,KAAM,UACN,KAAM,UACN,QAAS,yDACT,QAAS,EACX,CAAC,EAEH,QAAQ,IAAIC,CAAK,EACjB,QAAQ,IAAI,CAAC,SAAAE,CAAQ,CAAC,EACtB,MAAMI,EAAG,MAAMJ,EAAU,CAAE,UAAW,EAAK,CAAC,EAC5C,IAAMK,EAAgC,CAAC,EAEjCC,EAAa,MAAM,MAAMjB,CAAwB,EACvD,QAAQ,IAAIiB,CAAU,EACtB,IAAIC,EAAiB,MAAMD,EAAW,KAAK,EAE3C,QAAQ,IAAI,iBAAkBC,CAAO,EAMrC,IAAMC,EAAqBD,EAAQ,KAAME,GAAMA,EAAE,KAAOhB,CAAE,EAC1D,QAAQ,IAAI,CAAC,mBAAAe,CAAkB,CAAC,EAEhC,IAAME,EAAiBF,EAAmB,MAAM,CAAC,EAAE,KAAK,KAClDG,EAAoBH,EAAmB,MAAM,CAAC,EAAE,KAAK,SAAS,CAAC,EAAE,QACjEI,EAAiBb,EAAK,KAAKC,EAAWU,CAAc,EACpDG,EAAaL,EAAmB,MAAM,CAAC,EAAE,MAE/CH,EAAY,KAAK,CACf,aAAcM,EACd,UAAWC,CACb,CAAC,EAED,IAAME,EAAuB,CAAC,EACJD,EACf,IAAKE,GAAO,CACrB,IAAMC,EAAkBD,EAAI,KACtBE,EAAqBF,EAAI,SAAS,CAAC,EAAE,QACrCG,EAAkBnB,EAAK,KAAKC,EAAYgB,CAAe,EAC7DX,EAAY,KAAK,CACf,aAAcY,EACd,UAAWC,CACb,CAAC,CACH,CAAC,EACD,IAAMC,EAAyBX,EAAmB,aAC5CY,EAAUC,EAAI,0BAA0B,EAAE,MAAM,EAClDhB,EAGFA,EAAY,IAAI,MAAM,CAAC,aAAAiB,EAAe,UAAAC,CAAS,IAAM,CACnD,MAAMnB,EAAG,UAAU,GAAGmB,QAAkBD,CAAY,CACtD,CAAC,EAJDpB,EAAO,KAAK,qBAAqB,EAqB/BiB,GAAc,QAChB,MAAMK,EAAM,OAAQ,CAAC,UAAW,GAAGL,CAAY,EAAG,CAAE,IAAK,QAAQ,IAAI,CAAE,CAAC,EAE1EC,EAAQ,QAAQ,wBAAwB,CAC1C,OAASK,EAAP,CACA,QAAQ,IAAI,UAAWA,CAAG,CAC5B,CACF,CAAC,EEvIH,OAAOC,MAAU,OACjB,OAAOC,MAAQ,WAGR,SAASC,GAAiB,CAC/B,IAAMC,EAAkBH,EAAK,KAAK,cAAc,EAEhD,OAAOC,EAAG,aAAaE,CAAe,CACxC,CHFA,QAAQ,GAAG,SAAU,IAAM,QAAQ,KAAK,CAAC,CAAC,EAC1C,QAAQ,GAAG,UAAW,IAAM,QAAQ,KAAK,CAAC,CAAC,EAE3C,eAAeC,GAAO,CACpB,IAAMC,EAAc,MAAMC,EAAe,EAEnCC,EAAU,IAAIC,EAAQ,EACzB,KAAK,QAAQ,EACb,YAAY,oCAAoC,EAChD,QACCH,EAAY,SAAW,QACvB,gBACA,4BACF,EAEFE,EAAQ,WAAWE,CAAG,EAEtBF,EAAQ,MAAM,CAChB,CAEAH,EAAK","names":["Command","existsSync","fs","path","gradient","Command","ora","execa","prompts","chalk","logger","args","COMPONENT_REGISTERY_URL","gradient","add","Command","id","opts","defaultDir","dir","prompts","path_","path","root_dir","existsSync","logger","proceed","fs","path_to_add","comp_fetch","comp_db","select_files_by_id","x","root_comp_name","root_comp_content","root_comp_path","child_comp","child_path","dep","child_comp_name","child_comp_content","child_comp_path","dependencies","spinner","ora","comp_content","comp_path","execa","err","path","fs","getPackageInfo","packageJsonPath","main","packageInfo","getPackageInfo","program","Command","add"]}